/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { InstantiateMsg, LockConfig, ExecuteMsg, Uint128, Binary, StakeType, CallbackMsg, Addr, Cw20ReceiveMsg, UpdateConfigMsg, RewardDistributionConfig, QueryMsg, Config, ArrayOfLockupInfoResponse, LockupInfoResponse, LpLockupStateResponse, SingleLockupStateResponse, BalanceResponse, AssetInfo, ArrayOfUserLpLockupInfoResponse, UserLpLockupInfoResponse, Asset, ArrayOfUserSingleLockupInfoResponse, UserSingleLockupInfoResponse } from "./Lockdrop.types";
import { LockdropQueryClient, LockdropClient } from "./Lockdrop.client";
export const lockdropQueryKeys = {
  contract: ([{
    contract: "lockdrop"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...lockdropQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...lockdropQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  rewardConfig: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...lockdropQueryKeys.address(contractAddress)[0],
    method: "reward_config",
    args
  }] as const),
  owner: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...lockdropQueryKeys.address(contractAddress)[0],
    method: "owner",
    args
  }] as const),
  singleLockupInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...lockdropQueryKeys.address(contractAddress)[0],
    method: "single_lockup_info",
    args
  }] as const),
  lpLockupInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...lockdropQueryKeys.address(contractAddress)[0],
    method: "lp_lockup_info",
    args
  }] as const),
  singleLockupState: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...lockdropQueryKeys.address(contractAddress)[0],
    method: "single_lockup_state",
    args
  }] as const),
  lpLockupState: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...lockdropQueryKeys.address(contractAddress)[0],
    method: "lp_lockup_state",
    args
  }] as const),
  userSingleLockupInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...lockdropQueryKeys.address(contractAddress)[0],
    method: "user_single_lockup_info",
    args
  }] as const),
  userLpLockupInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...lockdropQueryKeys.address(contractAddress)[0],
    method: "user_lp_lockup_info",
    args
  }] as const),
  totalEclipIncentives: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...lockdropQueryKeys.address(contractAddress)[0],
    method: "total_eclip_incentives",
    args
  }] as const)
};
export const lockdropQueries = {
  config: <TData = Config,>({
    client,
    options
  }: LockdropConfigQuery<TData>): UseQueryOptions<Config, Error, TData> => ({
    queryKey: lockdropQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  rewardConfig: <TData = RewardDistributionConfig,>({
    client,
    options
  }: LockdropRewardConfigQuery<TData>): UseQueryOptions<RewardDistributionConfig, Error, TData> => ({
    queryKey: lockdropQueryKeys.rewardConfig(client?.contractAddress),
    queryFn: () => client ? client.rewardConfig() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  owner: <TData = Addr,>({
    client,
    options
  }: LockdropOwnerQuery<TData>): UseQueryOptions<Addr, Error, TData> => ({
    queryKey: lockdropQueryKeys.owner(client?.contractAddress),
    queryFn: () => client ? client.owner() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  singleLockupInfo: <TData = ArrayOfLockupInfoResponse,>({
    client,
    options
  }: LockdropSingleLockupInfoQuery<TData>): UseQueryOptions<ArrayOfLockupInfoResponse, Error, TData> => ({
    queryKey: lockdropQueryKeys.singleLockupInfo(client?.contractAddress),
    queryFn: () => client ? client.singleLockupInfo() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  lpLockupInfo: <TData = ArrayOfLockupInfoResponse,>({
    client,
    options
  }: LockdropLpLockupInfoQuery<TData>): UseQueryOptions<ArrayOfLockupInfoResponse, Error, TData> => ({
    queryKey: lockdropQueryKeys.lpLockupInfo(client?.contractAddress),
    queryFn: () => client ? client.lpLockupInfo() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  singleLockupState: <TData = SingleLockupStateResponse,>({
    client,
    options
  }: LockdropSingleLockupStateQuery<TData>): UseQueryOptions<SingleLockupStateResponse, Error, TData> => ({
    queryKey: lockdropQueryKeys.singleLockupState(client?.contractAddress),
    queryFn: () => client ? client.singleLockupState() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  lpLockupState: <TData = LpLockupStateResponse,>({
    client,
    options
  }: LockdropLpLockupStateQuery<TData>): UseQueryOptions<LpLockupStateResponse, Error, TData> => ({
    queryKey: lockdropQueryKeys.lpLockupState(client?.contractAddress),
    queryFn: () => client ? client.lpLockupState() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  userSingleLockupInfo: <TData = ArrayOfUserSingleLockupInfoResponse,>({
    client,
    args,
    options
  }: LockdropUserSingleLockupInfoQuery<TData>): UseQueryOptions<ArrayOfUserSingleLockupInfoResponse, Error, TData> => ({
    queryKey: lockdropQueryKeys.userSingleLockupInfo(client?.contractAddress, args),
    queryFn: () => client ? client.userSingleLockupInfo({
      user: args.user
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  userLpLockupInfo: <TData = ArrayOfUserLpLockupInfoResponse,>({
    client,
    args,
    options
  }: LockdropUserLpLockupInfoQuery<TData>): UseQueryOptions<ArrayOfUserLpLockupInfoResponse, Error, TData> => ({
    queryKey: lockdropQueryKeys.userLpLockupInfo(client?.contractAddress, args),
    queryFn: () => client ? client.userLpLockupInfo({
      user: args.user
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  totalEclipIncentives: <TData = BalanceResponse,>({
    client,
    options
  }: LockdropTotalEclipIncentivesQuery<TData>): UseQueryOptions<BalanceResponse, Error, TData> => ({
    queryKey: lockdropQueryKeys.totalEclipIncentives(client?.contractAddress),
    queryFn: () => client ? client.totalEclipIncentives() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface LockdropReactQuery<TResponse, TData = TResponse> {
  client: LockdropQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface LockdropTotalEclipIncentivesQuery<TData> extends LockdropReactQuery<BalanceResponse, TData> {}
export function useLockdropTotalEclipIncentivesQuery<TData = BalanceResponse>({
  client,
  options
}: LockdropTotalEclipIncentivesQuery<TData>) {
  return useQuery<BalanceResponse, Error, TData>(lockdropQueryKeys.totalEclipIncentives(client?.contractAddress), () => client ? client.totalEclipIncentives() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LockdropUserLpLockupInfoQuery<TData> extends LockdropReactQuery<ArrayOfUserLpLockupInfoResponse, TData> {
  args: {
    user: Addr;
  };
}
export function useLockdropUserLpLockupInfoQuery<TData = ArrayOfUserLpLockupInfoResponse>({
  client,
  args,
  options
}: LockdropUserLpLockupInfoQuery<TData>) {
  return useQuery<ArrayOfUserLpLockupInfoResponse, Error, TData>(lockdropQueryKeys.userLpLockupInfo(client?.contractAddress, args), () => client ? client.userLpLockupInfo({
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LockdropUserSingleLockupInfoQuery<TData> extends LockdropReactQuery<ArrayOfUserSingleLockupInfoResponse, TData> {
  args: {
    user: Addr;
  };
}
export function useLockdropUserSingleLockupInfoQuery<TData = ArrayOfUserSingleLockupInfoResponse>({
  client,
  args,
  options
}: LockdropUserSingleLockupInfoQuery<TData>) {
  return useQuery<ArrayOfUserSingleLockupInfoResponse, Error, TData>(lockdropQueryKeys.userSingleLockupInfo(client?.contractAddress, args), () => client ? client.userSingleLockupInfo({
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LockdropLpLockupStateQuery<TData> extends LockdropReactQuery<LpLockupStateResponse, TData> {}
export function useLockdropLpLockupStateQuery<TData = LpLockupStateResponse>({
  client,
  options
}: LockdropLpLockupStateQuery<TData>) {
  return useQuery<LpLockupStateResponse, Error, TData>(lockdropQueryKeys.lpLockupState(client?.contractAddress), () => client ? client.lpLockupState() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LockdropSingleLockupStateQuery<TData> extends LockdropReactQuery<SingleLockupStateResponse, TData> {}
export function useLockdropSingleLockupStateQuery<TData = SingleLockupStateResponse>({
  client,
  options
}: LockdropSingleLockupStateQuery<TData>) {
  return useQuery<SingleLockupStateResponse, Error, TData>(lockdropQueryKeys.singleLockupState(client?.contractAddress), () => client ? client.singleLockupState() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LockdropLpLockupInfoQuery<TData> extends LockdropReactQuery<ArrayOfLockupInfoResponse, TData> {}
export function useLockdropLpLockupInfoQuery<TData = ArrayOfLockupInfoResponse>({
  client,
  options
}: LockdropLpLockupInfoQuery<TData>) {
  return useQuery<ArrayOfLockupInfoResponse, Error, TData>(lockdropQueryKeys.lpLockupInfo(client?.contractAddress), () => client ? client.lpLockupInfo() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LockdropSingleLockupInfoQuery<TData> extends LockdropReactQuery<ArrayOfLockupInfoResponse, TData> {}
export function useLockdropSingleLockupInfoQuery<TData = ArrayOfLockupInfoResponse>({
  client,
  options
}: LockdropSingleLockupInfoQuery<TData>) {
  return useQuery<ArrayOfLockupInfoResponse, Error, TData>(lockdropQueryKeys.singleLockupInfo(client?.contractAddress), () => client ? client.singleLockupInfo() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LockdropOwnerQuery<TData> extends LockdropReactQuery<Addr, TData> {}
export function useLockdropOwnerQuery<TData = Addr>({
  client,
  options
}: LockdropOwnerQuery<TData>) {
  return useQuery<Addr, Error, TData>(lockdropQueryKeys.owner(client?.contractAddress), () => client ? client.owner() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LockdropRewardConfigQuery<TData> extends LockdropReactQuery<RewardDistributionConfig, TData> {}
export function useLockdropRewardConfigQuery<TData = RewardDistributionConfig>({
  client,
  options
}: LockdropRewardConfigQuery<TData>) {
  return useQuery<RewardDistributionConfig, Error, TData>(lockdropQueryKeys.rewardConfig(client?.contractAddress), () => client ? client.rewardConfig() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LockdropConfigQuery<TData> extends LockdropReactQuery<Config, TData> {}
export function useLockdropConfigQuery<TData = Config>({
  client,
  options
}: LockdropConfigQuery<TData>) {
  return useQuery<Config, Error, TData>(lockdropQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface LockdropChangeInitTimeMutation {
  client: LockdropClient;
  msg: {
    initTime: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropChangeInitTimeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropChangeInitTimeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropChangeInitTimeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.changeInitTime(msg, fee, memo, funds), options);
}
export interface LockdropClaimOwnershipMutation {
  client: LockdropClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropClaimOwnershipMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropClaimOwnershipMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropClaimOwnershipMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.claimOwnership(fee, memo, funds), options);
}
export interface LockdropDropOwnershipProposalMutation {
  client: LockdropClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropDropOwnershipProposalMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropDropOwnershipProposalMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropDropOwnershipProposalMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.dropOwnershipProposal(fee, memo, funds), options);
}
export interface LockdropProposeNewOwnerMutation {
  client: LockdropClient;
  msg: {
    expiresIn: number;
    owner: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropProposeNewOwnerMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropProposeNewOwnerMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropProposeNewOwnerMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.proposeNewOwner(msg, fee, memo, funds), options);
}
export interface LockdropCallbackMutation {
  client: LockdropClient;
  msg: CallbackMsg;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropCallbackMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropCallbackMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropCallbackMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.callback(msg, fee, memo, funds), options);
}
export interface LockdropClaimRewardsAndOptionallyUnlockMutation {
  client: LockdropClient;
  msg: {
    amount?: Uint128;
    duration: number;
    stakeType: StakeType;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropClaimRewardsAndOptionallyUnlockMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropClaimRewardsAndOptionallyUnlockMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropClaimRewardsAndOptionallyUnlockMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.claimRewardsAndOptionallyUnlock(msg, fee, memo, funds), options);
}
export interface LockdropRelockSingleStakingMutation {
  client: LockdropClient;
  msg: {
    from: number;
    to: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropRelockSingleStakingMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropRelockSingleStakingMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropRelockSingleStakingMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.relockSingleStaking(msg, fee, memo, funds), options);
}
export interface LockdropIncreaseEclipIncentivesMutation {
  client: LockdropClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropIncreaseEclipIncentivesMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropIncreaseEclipIncentivesMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropIncreaseEclipIncentivesMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.increaseEclipIncentives(fee, memo, funds), options);
}
export interface LockdropLpLockupWithdrawMutation {
  client: LockdropClient;
  msg: {
    amount?: Uint128;
    duration: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropLpLockupWithdrawMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropLpLockupWithdrawMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropLpLockupWithdrawMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.lpLockupWithdraw(msg, fee, memo, funds), options);
}
export interface LockdropSingleLockupWithdrawMutation {
  client: LockdropClient;
  msg: {
    amount?: Uint128;
    duration: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropSingleLockupWithdrawMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropSingleLockupWithdrawMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropSingleLockupWithdrawMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.singleLockupWithdraw(msg, fee, memo, funds), options);
}
export interface LockdropExtendLockMutation {
  client: LockdropClient;
  msg: {
    from: number;
    stakeType: StakeType;
    to: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropExtendLockMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropExtendLockMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropExtendLockMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.extendLock(msg, fee, memo, funds), options);
}
export interface LockdropStakeToVaultsMutation {
  client: LockdropClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropStakeToVaultsMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropStakeToVaultsMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropStakeToVaultsMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.stakeToVaults(fee, memo, funds), options);
}
export interface LockdropUpdateRewardDistributionConfigMutation {
  client: LockdropClient;
  msg: {
    newConfig: RewardDistributionConfig;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropUpdateRewardDistributionConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropUpdateRewardDistributionConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropUpdateRewardDistributionConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateRewardDistributionConfig(msg, fee, memo, funds), options);
}
export interface LockdropUpdateConfigMutation {
  client: LockdropClient;
  msg: {
    newConfig: UpdateConfigMsg;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}
export interface LockdropReceiveMutation {
  client: LockdropClient;
  msg: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useLockdropReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, LockdropReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, LockdropReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receive(msg, fee, memo, funds), options);
}